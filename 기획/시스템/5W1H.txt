when:
where:
who:
what:
why:
how:

운명 물체의 상태를 변경 및 선택할 수 있으며 이에 따라 게임 내 성공과 실패가 갈림
when: 운명 싸이클
where: 물체의 위치에서
who: 플레이어가
what: 상태를 가진 물체를
why: 상태를 변경함으로서 피드백을 주고 이는 원하는 운명으로 가기 위한 정보가 됨

how: 각 물체마다 변경할 수 있는 상태를 저장해야 하며 버튼을 누를 때마다 이를 순차적으로 보여줘야 함. UI는 물체 주변에 화살표 버튼을 2개 보여주고 클릭 시 다음 혹은 이전 상태를 보여줌. 변경할 수 있는 상태가 없으면 화살표는 비활성화 됨. 예를들어 다음상태가 없으면 ->화살표가 보이지 않아야 함. 프로그래밍 시 상태를 배열로 관리하고 index로 상태를 변환하며 다음, 이전 상태로 전활할 수 있는지 체크하고 이를 이용해 UI에서 버튼을 비활성화하고 관련 Sprite를 출력해야 함.


서로 다른 장소를 옮겨다니면서 운명 트리거를 조작할 수 있음
when: 운명 싸이클
where: 이동할 수 있는 범위 내에서
who: 플레이어가
what: 운명 물체를
why: 여러 장소에서 정보를 얻은 정보를 종합해 스테이지를 클리어할 수 있도록 하여 더 복잡한 수준의 예측을 촉진하게 하기 위함
how: 이동할 수 있는 맵의 리스트를 만들어서 클릭 시 카메라 위치 변화. 프로그래밍 시 위치들의 컬랙션을 보관하고 클릭된 장소의 위치로 카메라를 이동시켜야 함.


시뮬리이션 모드에서는 캐릭터가 움직이거나 대화하며 때때로 실시간으로 운명 물체를 조작할 수 있음
when: 시뮬레이션 모드
where: 운명 물체의 위치
who: 플레이어가
what: 운명 물체를
why: 실시간으로 무언가를 함으로서 긴박감을 주기 위함. 이 또한 예측의 일환이지만 계획 모드와는 다르게 굉장히 쉬운 수준의 예측을 제공하며 여기서의 예측은 상태의 조합보다는 '타이밍'에 저 집중됨. 또한 시뮬레이션 중에는 주로 캐릭터들의 움직임과 대화로 스토리가 진행되기에 스토리와 플레이가 병렬적으로 진행될 수 있음.

how: 계획 모드에서 어떤 물체가 어떤 상태였는지에 따라 시뮬레이션이 달라져야 함. 여기에는 '실패'도 포함되며 이 경우 운명 싸이클의 처음으로 돌아감. 이를 위해서는 싸이클마다 일종의 분기가 필요하며 이는 계획 모드에서의 조건에 따라 어떤 시뮬레이션을 실행할지를 미리 정해놔야 함. 이를 위해서는 각 조건과 그에 따른 시뮬레이션을 설정할 수 있는 기획자 전용 UI가 필요함.

조작 가능한 운명 물체의 종류 및 상태 역시 달라져야 하며 시간에 흐름에 따라 활성화하거나 비활성화 되는 기능도 있어야 함. 이를 위해서는 계획 모드와 시뮬레이션 모드의 조작 가능한 물체를 별도의 컬랙션으로 관리해야 하며 각 운명 물체마다 조건을 설정해 시간의 흐름, 혹은 다른 운명 물체의 상태에 따라 조작 가능 상태를 변경해야 함. 

조건의 타입을 구분해야 하며 2개 이상의 조건이 필요할 수도 있으므로 모든 조건을 만족해야만 조작을 활성화시켜야 함. 이는 조건을 추상화해 명령 패턴과 컴포지트 패턴을 조합하거나 enum과 이들 이들 컬랙션을 다루는 방식으로 구현할 수 있음. 조건에 변화가 많을 것이라고 예상된다면 추상화를 하는 쪽이 좋지만 코드의 복잡도는 증가함.


플레이어는 미리보기에서 본 원래 세상의 운명을 계획 모드와 시뮬레이션 모드 중 운명 물체를 조작함으로서 바꿀 수 있으며 이를 운명 싸이클로 부름
when: 운명 싸이클
where: 운명 변화에 필요한 정보나 운명 물체가 있는 장소
who: 시스템
what: 운명을
why: 각각의 모드를 구분함으로서 플레이어가 각 상황의 목표에 온전히 집중할 수 있게 함. 미리보기에서는 자신이 어떻게 세상을 바꿔야하는지 고민하고 계획모드에서는 여러 상태를 조합해 옳은 상태를 찾아야 하며 시뮬레이션 모드에서는 스토리를 감상하면서 때때로 타이밍에 맞춰 물체를 조작해야 함.
how: 각 모드마다 UI와 조작할 수 있는 범위가 다름. 프로그래밍 시 현재 상태를 저장하고 변환하는 도매인 클래스가 필요하며 UI에서 이 값을 기반으로 관련 요소들을 그려야 함.


미리보기에서는 원래의 운명을 보여줌
when: 운명 변화 시작 시
where: 운명을 바꿀 공간
who: 시스템이
what: 원래 세상의 운명을
why: 바뀌기 전의 모습을 보여줌으로서 플레이어에게 어떻게 운명을 바꿔야할지 예측하게 해줌
how: 캐릭터 움직임, 대화 기능들을 조합해 하나의 시뮬레이션을 보여줘야 함. 모든 시뮬레이션을 하드코딩하는 것은 비효율적이므로 이를 위한 전용 툴을 개발해야 함. 가장 간단한 것을 엑셀이나 메모장에 연속적인 명령을 받아 이를 코드에서 변환할 수 있음. 더 유저 친화적인 것은 전용 에디터 UI를 개발하는 것. 이는 엔진마다 다르지만 Unity의 경우 별도의 에디터 프로그래밍을 통해 다양한 UI를 만들 수 있음.


운명은 여러 운명 싸이클을 가지고 있음. 이는 일종의 체크포인트 역할을 하며 운명 갱신 실패 시 그 부분부터 다시 시작할 수 있음
when: 운명
where: 운명이 바뀌는 곳
who: 시스템이
what: 기준을
why: 같은 시뮬레이션을 계속 보면 지루해지는데 이를 방지하기 위함
how: 여러 개의 운명 사이클을 연결해야 함. 시뮬레이션 모드가 끝난 후 다시 새로운 싸이클의 미리보기가 시작되어야 하며 이는 준비된 싸이클이 바닥날 때까지 반복됨. 하나의 운명에 몇 개의 싸이클이 있을지는 기획자가 직접 작업해야 좋으므로 에디터 프로그래밍이 필요함. 이를 위해서는 싸이클을 하나의 집합으로 묶고 UI에서 이를 자유롭게 추가, 삭제, 수정할 수 있는 기능이 필요함.


계획 모드 중에는 여러 운명 물체들의 상태를 변경할 수 있음
when: 운명 싸이클
where: 운명이 바뀌는 곳
who: 플레이어가
what: 운명 물체들을
why: 상태 선택에 따라 다른 시뮬레이션을 실행하기 위함. 플레이어는 조작으로 인해 자신의 예측을 실현할 수 있으며 원하는 결과를 얻으면 만족감을 느낌.
how: 설정이 끝나고 시뮬레이션을 실행하는 버튼이 필요함.
결과에 따라 다른 시뮬레이션이 실행되게 하기 위해서는 물체의 상태를 저장하고 이것이 미리 설정한 통과 조건과 일치하는지 확인하는 로직이 필요함. 각 물체의 상태를 index로 표현하는 등의 작업을 통해 비교 가능하게 상태를 정의해야 함.


날씨 선택
카메라가 플레이어 포커스고 물건은 물건 가운데에 포커스
when:
where:
who:
what:
why:
how:


인벤토리, 목표 TODO리스트, 대화 로그 볼 수 있게 하기
when:
where:
who:
what:
why:
how:


물체끼리의 상호작용 보여주기
when:
where:
who:
what:
why:
how:

