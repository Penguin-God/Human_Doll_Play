when:
where:
who:
what:
why:
how:
question:

운명 물체 조작
when: 운명 싸이클
where: 물체의 위치에서
who: 플레이어가
what: 상태를 가진 물체를
how: 각 물체마다 변경할 수 있는 상태를 저장해야 함. 한 번에 하나의 물체만 조작할 수 있음.
운명 물체는 다른 오브젝트와 달리 특별한 표시가 되어 있음.
물체를 조작할 때에는 그 물체를 클릭해 포커스해야 함.
포커스된 물체 주위에는 <-, -> 모양의 화살표 버튼이 생김. 버튼을 누를 때마다 상태를 변경해야 함. 이때 화살표에 따라 다음 혹은 이전 상태를 보여줌. 
변경할 수 있는 상태가 없으면 화살표는 비활성화 됨. 예를들어 다음상태가 없으면 ->화살표가 보이지 않아야 함. 
프로그래밍 시 상태를 배열로 관리하고 index로 상태를 변환하며 다음, 이전 상태로 전활할 수 있는지 체크하고 이를 이용해 UI에서 버튼을 비활성화하고 관련 Sprite를 출력해야 함.
why: 상태를 변경함으로서 피드백을 주고 이는 원하는 운명으로 가기 위한 정보가 됨

qusetion: 운명 물체를 가리키는 특별한 표시는 무엇인가. 윤곽선인가 여러 상태가 겹치는 모습인가 아니면 반투명인가.


운명 장소 변경
when: 운명 싸이클
where: 이동할 수 있는 범위 내에서
who: 플레이어가
what: 운명 물체를

how: 이동할 수 있는 맵이 왼쪽 하단에 사각형 이미지의 나열로 보이며 이를 클릭 시 그곳으로 이동함. 
위치들의 컬랙션을 보관하고 클릭된 장소의 위치로 카메라를 이동시켜야 함.

why: 여러 장소에서 정보를 얻은 정보를 종합해 스테이지를 클리어할 수 있도록 하여 더 복잡한 수준의 예측을 촉진하게 하기 위함


계획 모드
when: 계획 모드
where: 운명이 바뀌는 곳
who: 플레이어가
what: 운명 물체들을

how: 계획 모드는 운명 싸이클 중 하나의 단계로 운명 물체들의 상태를 변경해 다른 시뮬레이션이 실행되도록 함. 
오른쪽 하단의 버튼을 클릭해 설정을 끝내고 시뮬레이션을 실행할 수 있음.
결과에 따라 다른 시뮬레이션이 실행되게 하기 위해서는 물체의 상태를 저장하고 이것이 미리 설정한 통과 조건과 일치하는지 확인하는 로직이 필요함. 
각 물체의 상태를 index로 표현하는 등의 작업을 통해 비교 가능하게 상태를 정의해야 함.

why: 상태 선택에 따라 다른 시뮬레이션을 실행하기 위함. 플레이어는 조작으로 인해 자신의 예측을 실현할 수 있으며 원하는 결과를 얻으면 만족감을 느낌.


시뮬리이션 모드
when: 시뮬레이션 모드
where: 운명이 바뀌는 곳
who: 플레이어가
what: 운명 물체를

how: 시뮬레이션 모드에서 계획 모드에서 설정한 상태에 따라 캐릭터가 움직이거나, 대화를 하는 등의 시뮬레이션이 실행됨.
계획 모드의 설정값에 따라 다른 시뮬레이션이 실행되어야 하며 여기에는 '실패'도 포함되어 있음.
이를 위해서는 싸이클마다 일종의 분기가 필요하며 그에 따라 어떤 시뮬레이션을 실행할지를 미리 정해놔야 함. 그러므로 관련 작업을 위한 기획자 전용 UI필요.

설정값에 따라 조작 가능한 운명 물체의 종류 및 상태 역시 달라져야 함.
실시간으로 조작 가능한 물체의 경우 시간에 흐름에 따라 조작이 활성화하거나 비활성화 되는 기능도 있어야 함.

코딩 시 계획 모드와 시뮬레이션 모드의 조작 가능한 물체를 별도의 컬랙션으로 관리해야 하며 각 운명 물체마다 조건을 설정해 시간의 흐름, 혹은 다른 운명 물체의 상태에 따라 조작 가능 상태를 변경해야 함. 
조건의 타입을 구분해야 하며 2개 이상의 조건이 필요할 수도 있으므로 모든 조건을 만족해야만 조작을 활성화해야야 함. 
이는 조건을 추상화해 명령 패턴과 컴포지트 패턴을 조합하거나 아니면 enum과 정의한 enum타입의 컬랙션을 다루는 방식으로 구현할 수 있음. 조건에 변화가 많을 것이라고 예상된다면 추상화를 하는 쪽이 좋지만 코드의 복잡도는 증가함.

why: 실시간으로 무언가를 함으로서 긴박감을 주기 위함. 이 또한 예측의 일환이지만 계획 모드와는 다르게 굉장히 쉬운 수준의 예측을 제공하며 여기서의 예측은 상태의 조합보다는 '타이밍'에 저 집중됨. 또한 시뮬레이션 중에는 주로 캐릭터들의 움직임과 대화로 스토리가 진행되기에 스토리와 플레이가 병렬적으로 진행될 수 있음.


운명 싸이클
when: 운명 싸이클
where: 운명 변화에 필요한 정보나 운명 물체가 있는 장소
who: 시스템
what: 운명을

how: 운명 싸이클은 미리보기와 계획 모드 시뮬레이션 모드로 이루어진 하나의 단위임. 
각 모드마다 UI와 조작할 수 있는 범위가 다르며 이는 각 모드의 세부 기획에 나와있음.
프로그래밍 시 현재 상태를 저장하고 변환하는 도매인 클래스가 필요하며 UI에서 이 값을 기반으로 관련 요소들을 그려야 함.

why: 모드를 구분함으로서 플레이어가 상황에 따른 목표에 온전히 집중할 수 있게 함.
미리보기에서는 자신이 어떻게 세상을 바꿔야하는지 계획하고 계획모드에서는 여러 상태를 조합해 주인공의 행동을 유도해야 하며 시뮬레이션 모드에서는 스토리를 감상하면서 때때로 타이밍에 맞춰 물체를 조작해야 함.


미리보기에서는 원래의 운명을 보여줌 - 수정 필요
when: 운명 변화 시작 시
where: 운명을 바꿀 공간
who: 시스템이
what: 원래 세상의 운명을
why: 바뀌기 전의 모습을 보여줌으로서 플레이어에게 어떻게 운명을 바꿔야할지 예측하게 해줌
how: 캐릭터 움직임, 대화 기능들을 조합해 하나의 시뮬레이션을 보여줘야 함. 모든 시뮬레이션을 하드코딩하는 것은 비효율적이므로 이를 위한 전용 툴을 개발해야 함. 가장 간단한 것을 엑셀이나 메모장에 연속적인 명령을 받아 이를 코드에서 변환할 수 있음. 더 유저 친화적인 것은 전용 에디터 UI를 개발하는 것. 이는 엔진마다 다르지만 Unity의 경우 별도의 에디터 프로그래밍을 통해 다양한 UI를 만들 수 있음.


운명
when:
where: 
who: 
what: 
why: 
how: 



날씨 선택
카메라가 플레이어 포커스고 물건은 물건 가운데에 포커스
when:
where:
who:
what:
why:
how:


인벤토리, 목표 TODO리스트, 대화 로그
when:
where:
who:
what:
why:
how:


운명 물체끼리의 상호작용
when:
where:
who:
what:
why:
how:


캐릭터 움직임
when:
where:
who:
what:
why:
how:


캐릭터 대화
when:
where:
who:
what:
why:
how:


운명 갱신
when: 시뮬레이션 모드
where: 운명이 바뀌는 곳
who: 시스템이
what: 운명 갱신을
why: 같은 시뮬레이션을 계속 보면 지루해지는데 이를 방지하기 위함
how: 운명 갱신은 원래 세상과 다른 결과가 생김으로서 운명이 변하는 기준점을 뜻함.
운명은 하나의 큰 사건이 변경되어야 함.
운명 싸이클은 변경될 수 있는 세부적인 운명을 가지고 있음.
다수의 운명 싸이클이 모여 하나의 커다란 운명을 바꾸고 세상을 새로운 길로 이끔.
즉, 운명은 여러 운명 싸이클을 가지고 있는데 이를 일종의 체크포인트 역할로서 활용해 운명 갱신 실패 시 그 부분부터 다시 시작할 수 있음.

코딩 시 여러 개의 운명 사이클을 연결해야 함. 시뮬레이션 모드가 끝난 후 다시 새로운 싸이클의 미리보기가 시작되어야 하며 이는 준비된 싸이클이 끝날 때까지 반복됨.
하나의 운명에 몇 개의 싸이클이 있을지는 기획자가 직접 작업해야 좋으므로 에디터 프로그래밍이 필요함. 이를 위해서는 싸이클을 하나의 집합으로 묶고 UI에서 이를 자유롭게 추가, 삭제, 수정할 수 있는 기능이 필요함.